#!/bin/bash
# Compose Manager - Docker Stopping Event Handler
# Gracefully stops all compose stacks before Docker shuts down
# Features: timeout protection, logging, graceful degradation

source /usr/local/emhttp/plugins/compose.manager/default.cfg
source /boot/config/plugins/compose.manager/compose.manager.cfg

COMPOSE_ROOT=$PROJECTS_FOLDER
LOG_FILE="/var/log/compose.manager.log"

# Configuration with defaults
SHUTDOWN_TIMEOUT=${SHUTDOWN_TIMEOUT:-60}

# Logging helper
log() {
    local msg="[$(date '+%Y-%m-%d %H:%M:%S')] $1"
    echo "$msg" >> "$LOG_FILE"
    logger -t "compose.manager" "$1"
}

source /usr/local/emhttp/plugins/compose.manager/scripts/common.sh

# Stop a single stack with timeout
stop_stack() {
    local dir="$1"
    local stack_name="$2"
    local sanitized_name="$3"
    local start_time=$(date +%s)
    
    log "Stopping stack: $stack_name"
    
    # Build command arguments
    local -a file_args=()
    if [ -f "$dir/indirect" ]; then
        local indirect
        indirect=$(< "$dir/indirect")
        local compose_file
        if ! compose_file=$(find_compose_file "$indirect"); then
            compose_file="$indirect/docker-compose.yml"
        fi
        file_args=("-f" "$compose_file")
    else
        local compose_file
        if ! compose_file=$(find_compose_file "$dir"); then
            compose_file="$dir/docker-compose.yml"
        fi
        file_args=("-f" "$compose_file")
    fi
    
    local -a override_args=()
    if [ -f "$dir/docker-compose.override.yml" ]; then
        override_args=("-f" "$dir/docker-compose.override.yml")
    fi
    
    local -a env_args=()
    if [ -f "$dir/envpath" ]; then
        local envpath
        envpath=$(< "$dir/envpath")
        if [ -f "$envpath" ]; then
            env_args=("--env-file" "$envpath")
        fi
    fi
    
    # Try graceful stop first with timeout
    local exit_code
    timeout $SHUTDOWN_TIMEOUT docker compose "${file_args[@]}" "${override_args[@]}" "${env_args[@]}" -p "$sanitized_name" stop 2>&1
    exit_code=$?
    
    local duration=$(($(date +%s) - start_time))
    
    if [ $exit_code -eq 0 ]; then
        log "Stack $stack_name stopped successfully in ${duration}s"
        return 0
    elif [ $exit_code -eq 124 ]; then
        log "WARNING: Stack $stack_name stop timed out after ${SHUTDOWN_TIMEOUT}s, forcing..."
        # Force kill containers if graceful stop times out
        docker compose "${file_args[@]}" "${override_args[@]}" "${env_args[@]}" -p "$sanitized_name" kill 2>&1
        log "Stack $stack_name force killed"
        return 124
    else
        log "ERROR: Stack $stack_name failed to stop (exit code: $exit_code)"
        return $exit_code
    fi
}

# Main execution
log "=== Compose Manager Shutdown Begin ==="

# Collect all stacks (not just autostart ones - we need to stop everything)
declare -a stacks_to_stop

for dir in "$COMPOSE_ROOT"/*; do
    if [ -d "$dir" ]; then
        if has_compose_file "$dir" || [ -f "$dir/indirect" ]; then
            # Get stack name
            local_name=""
            if [ -f "$dir/name" ]; then
                local_name=$(< "$dir/name")
            else
                local_name=$(basename "$dir")
            fi
            
            stacks_to_stop+=("$dir|$local_name")
        fi
    fi
done

total_stacks=${#stacks_to_stop[@]}
log "Found $total_stacks stacks to stop"

if [ $total_stacks -eq 0 ]; then
    log "=== Compose Manager Shutdown Complete (no stacks) ==="
    exit 0
fi

# Stop stacks in parallel for faster shutdown
# (Unlike startup, we want shutdown to be quick)
for stack_entry in "${stacks_to_stop[@]}"; do
    dir="${stack_entry%%|*}"
    stack_name="${stack_entry#*|}"
    sanitized_name=$(sanitize "$stack_name")
    
    stop_stack "$dir" "$stack_name" "$sanitized_name" &
done

# Wait for all stops to complete
wait

log "=== Compose Manager Shutdown Complete ==="
